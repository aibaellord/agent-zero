/**
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 * â–ˆ                                                                          â–ˆ
 * â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—                   â–ˆ
 * â–ˆ   â–ˆâ–ˆâ•”â•â•â•â•â•â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•                   â–ˆ
 * â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘                      â–ˆ
 * â–ˆ   â–ˆâ–ˆâ•”â•â•â•   â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•â•â• â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘                      â–ˆ
 * â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘                      â–ˆ
 * â–ˆ   â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•                      â–ˆ
 * â–ˆ                                                                          â–ˆ
 * â–ˆ   ENGINE - MAXIMUM ADVANTAGE EXTRACTION SYSTEM                           â–ˆ
 * â–ˆ   Extract every possible advantage from every opportunity                â–ˆ
 * â–ˆ                                                                          â–ˆ
 * â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
 */

(function () {
  "use strict";

  class BaelExploit {
    constructor() {
      this.exploits = new Map();
      this.advantages = [];
      this.opportunities = [];
      this.strategies = new Map();
      this.results = [];

      console.log("âš¡ Bael Exploit Engine initialized");
    }

    async initialize() {
      await this.setupTokenExploitation();
      await this.setupCacheExploitation();
      await this.setupParallelExploitation();
      await this.setupContextExploitation();
      await this.setupResourceExploitation();
      await this.setupTimingExploitation();
      await this.setupNetworkExploitation();
      await this.setupStorageExploitation();

      this.startOpportunityScanning();
      console.log("ðŸŽ¯ EXPLOIT ENGINE ACTIVE");
      return this;
    }

    /**
     * Token Exploitation - Maximize token efficiency
     */
    async setupTokenExploitation() {
      this.tokenExploit = {
        // Compress prompts to save tokens
        compressPrompt: (text) => {
          // Remove redundant whitespace
          let compressed = text.replace(/\s+/g, " ").trim();

          // Use abbreviations
          const abbreviations = {
            please: "pls",
            because: "bc",
            without: "w/o",
            with: "w/",
            information: "info",
            application: "app",
            configuration: "config",
            implementation: "impl",
            documentation: "docs",
            function: "fn",
            parameter: "param",
            variable: "var",
            constant: "const",
            development: "dev",
            production: "prod",
            environment: "env",
          };

          for (const [full, abbr] of Object.entries(abbreviations)) {
            compressed = compressed.replace(new RegExp(full, "gi"), abbr);
          }

          return compressed;
        },

        // Expand compressed response
        expandResponse: (text) => {
          // Expand common abbreviations back
          const expansions = {
            pls: "please",
            bc: "because",
            "w/o": "without",
            "w/": "with",
            info: "information",
            app: "application",
            config: "configuration",
            impl: "implementation",
            docs: "documentation",
            fn: "function",
            param: "parameter",
            var: "variable",
            dev: "development",
            prod: "production",
            env: "environment",
          };

          let expanded = text;
          for (const [abbr, full] of Object.entries(expansions)) {
            expanded = expanded.replace(
              new RegExp(`\\b${abbr}\\b`, "gi"),
              full,
            );
          }

          return expanded;
        },

        // Estimate token count
        estimateTokens: (text) => {
          // Rough estimation: ~4 chars per token
          return Math.ceil(text.length / 4);
        },

        // Optimize for token budget
        optimizeForBudget: (messages, budget) => {
          const optimized = [];
          let totalTokens = 0;

          // Process from most recent
          for (let i = messages.length - 1; i >= 0; i--) {
            const msg = messages[i];
            const compressed = this.tokenExploit.compressPrompt(msg.content);
            const tokens = this.tokenExploit.estimateTokens(compressed);

            if (totalTokens + tokens <= budget) {
              optimized.unshift({ ...msg, content: compressed });
              totalTokens += tokens;
            } else {
              break;
            }
          }

          return {
            messages: optimized,
            tokens: totalTokens,
            saved: messages.length - optimized.length,
          };
        },

        // Smart summarization
        summarize: (text, maxTokens) => {
          const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
          const scored = sentences.map((s) => ({
            text: s.trim(),
            score: this.scoreImportance(s),
          }));

          scored.sort((a, b) => b.score - a.score);

          let summary = "";
          let tokens = 0;

          for (const s of scored) {
            const sentenceTokens = this.tokenExploit.estimateTokens(s.text);
            if (tokens + sentenceTokens <= maxTokens) {
              summary += s.text + " ";
              tokens += sentenceTokens;
            }
          }

          return summary.trim();
        },
      };
    }

    /**
     * Cache Exploitation - Maximize cache efficiency
     */
    async setupCacheExploitation() {
      this.cacheExploit = {
        cache: new Map(),
        stats: { hits: 0, misses: 0, saves: 0 },

        // Aggressive caching
        get: (key) => {
          const cached = this.cacheExploit.cache.get(key);
          if (cached) {
            if (cached.expires && cached.expires < Date.now()) {
              this.cacheExploit.cache.delete(key);
              this.cacheExploit.stats.misses++;
              return null;
            }
            this.cacheExploit.stats.hits++;
            cached.accessCount++;
            cached.lastAccess = Date.now();
            return cached.value;
          }
          this.cacheExploit.stats.misses++;
          return null;
        },

        set: (key, value, options = {}) => {
          const entry = {
            value,
            created: Date.now(),
            lastAccess: Date.now(),
            accessCount: 1,
            expires: options.ttl ? Date.now() + options.ttl : null,
            priority: options.priority || "normal",
          };

          this.cacheExploit.cache.set(key, entry);
          this.cacheExploit.stats.saves++;

          // Auto-cleanup when cache gets large
          if (this.cacheExploit.cache.size > 1000) {
            this.cacheExploit.cleanup();
          }
        },

        // Predictive caching
        prefetch: async (predictions) => {
          for (const prediction of predictions) {
            if (!this.cacheExploit.cache.has(prediction.key)) {
              try {
                const value = await prediction.fetch();
                this.cacheExploit.set(prediction.key, value, {
                  priority: "prefetch",
                });
              } catch (e) {
                // Silent fail for prefetch
              }
            }
          }
        },

        // Smart cleanup
        cleanup: () => {
          const entries = Array.from(this.cacheExploit.cache.entries());

          // Score each entry
          const scored = entries.map(([key, entry]) => ({
            key,
            entry,
            score: this.calculateCacheScore(entry),
          }));

          // Remove lowest scored 20%
          scored.sort((a, b) => a.score - b.score);
          const removeCount = Math.floor(scored.length * 0.2);

          for (let i = 0; i < removeCount; i++) {
            this.cacheExploit.cache.delete(scored[i].key);
          }
        },

        // Get cache efficiency
        getEfficiency: () => {
          const { hits, misses } = this.cacheExploit.stats;
          const total = hits + misses;
          return total > 0 ? (hits / total) * 100 : 0;
        },
      };
    }

    /**
     * Parallel Exploitation - Maximize concurrency
     */
    async setupParallelExploitation() {
      this.parallelExploit = {
        // Execute tasks in parallel
        executeAll: async (tasks) => {
          const results = await Promise.allSettled(tasks.map((t) => t()));

          return results.map((r, i) => ({
            index: i,
            success: r.status === "fulfilled",
            result: r.value || r.reason,
          }));
        },

        // Execute with concurrency limit
        executeWithLimit: async (tasks, limit = 5) => {
          const results = [];
          const executing = [];

          for (const task of tasks) {
            const p = task()
              .then((r) => ({ success: true, result: r }))
              .catch((e) => ({ success: false, result: e }));

            results.push(p);
            executing.push(p);

            if (executing.length >= limit) {
              await Promise.race(executing);
              executing.splice(
                executing.findIndex((e) => e === p),
                1,
              );
            }
          }

          return Promise.all(results);
        },

        // Race for fastest result
        race: async (tasks) => {
          return Promise.race(tasks.map((t) => t()));
        },

        // Execute with fallback
        withFallback: async (primary, fallback) => {
          try {
            return await primary();
          } catch (e) {
            return await fallback();
          }
        },

        // Batch API calls
        batch: async (items, batchFn, batchSize = 10) => {
          const results = [];

          for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            const batchResults = await batchFn(batch);
            results.push(...batchResults);
          }

          return results;
        },

        // Auto-parallelize
        autoParallelize: (tasks, options = {}) => {
          const cpuCores = navigator.hardwareConcurrency || 4;
          const optimalConcurrency = Math.min(tasks.length, cpuCores * 2);

          return this.parallelExploit.executeWithLimit(
            tasks,
            optimalConcurrency,
          );
        },
      };
    }

    /**
     * Context Exploitation - Maximize context window usage
     */
    async setupContextExploitation() {
      this.contextExploit = {
        // Compress context
        compress: (context) => {
          // Remove redundant info
          const seen = new Set();
          const unique = context.filter((item) => {
            const key = JSON.stringify(item);
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });

          return unique;
        },

        // Prioritize context
        prioritize: (items, maxItems = 50) => {
          // Score each item
          const scored = items.map((item) => ({
            item,
            score: this.scoreContextItem(item),
          }));

          scored.sort((a, b) => b.score - a.score);

          return scored.slice(0, maxItems).map((s) => s.item);
        },

        // Build optimal context
        buildOptimal: (items, tokenBudget) => {
          const sorted = this.contextExploit.prioritize(items, items.length);
          const included = [];
          let tokens = 0;

          for (const item of sorted) {
            const itemTokens = this.tokenExploit.estimateTokens(
              JSON.stringify(item),
            );
            if (tokens + itemTokens <= tokenBudget) {
              included.push(item);
              tokens += itemTokens;
            }
          }

          return {
            items: included,
            tokens,
            utilization: (tokens / tokenBudget) * 100,
          };
        },

        // Smart chunking
        chunk: (text, chunkSize = 1000, overlap = 100) => {
          const chunks = [];
          let start = 0;

          while (start < text.length) {
            const end = Math.min(start + chunkSize, text.length);
            chunks.push({
              text: text.slice(start, end),
              start,
              end,
            });
            start = end - overlap;
          }

          return chunks;
        },

        // Semantic deduplication
        deduplicate: (items) => {
          const unique = [];
          const fingerprints = new Set();

          for (const item of items) {
            const fingerprint = this.generateFingerprint(item);
            if (!fingerprints.has(fingerprint)) {
              fingerprints.add(fingerprint);
              unique.push(item);
            }
          }

          return unique;
        },
      };
    }

    /**
     * Resource Exploitation - Maximize resource usage
     */
    async setupResourceExploitation() {
      this.resourceExploit = {
        // Optimize memory usage
        optimizeMemory: () => {
          // Trigger garbage collection if possible
          if (window.gc) {
            window.gc();
          }

          // Clear unnecessary data
          this.cacheExploit.cleanup();

          // Suggest large object cleanup
          return {
            action: "memory_optimized",
            timestamp: Date.now(),
          };
        },

        // Optimize CPU usage
        scheduleTasks: (tasks, priority = "normal") => {
          if ("scheduler" in window && "postTask" in window.scheduler) {
            return Promise.all(
              tasks.map((task) =>
                window.scheduler.postTask(task, { priority }),
              ),
            );
          }

          // Fallback to requestIdleCallback
          return new Promise((resolve) => {
            const results = [];
            let completed = 0;

            tasks.forEach((task, i) => {
              requestIdleCallback(() => {
                results[i] = task();
                completed++;
                if (completed === tasks.length) {
                  resolve(results);
                }
              });
            });
          });
        },

        // Optimize network
        optimizeNetwork: () => {
          // Enable HTTP/2 multiplexing (browser handles this)
          // Suggest prefetching
          const links = document.querySelectorAll("a[href]");
          const toPreload = Array.from(links)
            .filter((l) => l.href.startsWith(location.origin))
            .slice(0, 5);

          toPreload.forEach((link) => {
            const prefetch = document.createElement("link");
            prefetch.rel = "prefetch";
            prefetch.href = link.href;
            document.head.appendChild(prefetch);
          });

          return { prefetched: toPreload.length };
        },

        // Resource pooling
        pool: {
          workers: [],
          maxWorkers: navigator.hardwareConcurrency || 4,

          getWorker: function () {
            if (this.workers.length < this.maxWorkers) {
              const worker = new Worker(
                URL.createObjectURL(
                  new Blob(
                    [
                      `
                                self.onmessage = async (e) => {
                                    const { fn, args } = e.data;
                                    const result = await eval('(' + fn + ')').apply(null, args);
                                    self.postMessage(result);
                                };
                            `,
                    ],
                    { type: "text/javascript" },
                  ),
                ),
              );
              this.workers.push(worker);
            }
            return this.workers[
              Math.floor(Math.random() * this.workers.length)
            ];
          },
        },
      };
    }

    /**
     * Timing Exploitation - Maximize time efficiency
     */
    async setupTimingExploitation() {
      this.timingExploit = {
        // Debounce with leading edge
        debounce: (fn, delay, immediate = false) => {
          let timeout;
          return function (...args) {
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(() => {
              timeout = null;
              if (!immediate) fn.apply(this, args);
            }, delay);
            if (callNow) fn.apply(this, args);
          };
        },

        // Throttle with trailing edge
        throttle: (fn, limit) => {
          let inThrottle;
          let lastArgs;

          return function (...args) {
            if (!inThrottle) {
              fn.apply(this, args);
              inThrottle = true;
              setTimeout(() => {
                inThrottle = false;
                if (lastArgs) {
                  fn.apply(this, lastArgs);
                  lastArgs = null;
                }
              }, limit);
            } else {
              lastArgs = args;
            }
          };
        },

        // Execute during idle time
        whenIdle: (fn) => {
          return new Promise((resolve) => {
            requestIdleCallback(() => {
              resolve(fn());
            });
          });
        },

        // Measure and optimize
        measure: async (name, fn) => {
          const start = performance.now();
          const result = await fn();
          const duration = performance.now() - start;

          performance.mark(`${name}_end`);

          return { result, duration, name };
        },

        // Smart delay
        smartDelay: (baseMs, factor = 1) => {
          // Adjust based on system load
          const load = this.getSystemLoad();
          const adjusted = baseMs * (1 + load * factor);
          return new Promise((r) => setTimeout(r, adjusted));
        },

        // Rate limiter
        rateLimiter: (limit, interval) => {
          const queue = [];
          let tokens = limit;

          setInterval(() => {
            tokens = Math.min(limit, tokens + 1);
            while (tokens > 0 && queue.length > 0) {
              const { fn, resolve } = queue.shift();
              tokens--;
              resolve(fn());
            }
          }, interval / limit);

          return (fn) => {
            return new Promise((resolve) => {
              if (tokens > 0) {
                tokens--;
                resolve(fn());
              } else {
                queue.push({ fn, resolve });
              }
            });
          };
        },
      };
    }

    /**
     * Network Exploitation - Maximize network efficiency
     */
    async setupNetworkExploitation() {
      this.networkExploit = {
        // Request deduplication
        dedupe: (() => {
          const pending = new Map();

          return async (key, fetchFn) => {
            if (pending.has(key)) {
              return pending.get(key);
            }

            const promise = fetchFn();
            pending.set(key, promise);

            try {
              return await promise;
            } finally {
              pending.delete(key);
            }
          };
        })(),

        // Request coalescing
        coalesce: (() => {
          const queue = [];
          let timeout;

          return (request, delay = 50) => {
            return new Promise((resolve, reject) => {
              queue.push({ request, resolve, reject });

              clearTimeout(timeout);
              timeout = setTimeout(async () => {
                const batch = [...queue];
                queue.length = 0;

                // Execute all at once
                const results = await Promise.allSettled(
                  batch.map((b) => b.request()),
                );

                results.forEach((r, i) => {
                  if (r.status === "fulfilled") {
                    batch[i].resolve(r.value);
                  } else {
                    batch[i].reject(r.reason);
                  }
                });
              }, delay);
            });
          };
        })(),

        // Smart retry
        retry: async (fn, maxRetries = 3, delay = 1000) => {
          let lastError;

          for (let i = 0; i < maxRetries; i++) {
            try {
              return await fn();
            } catch (error) {
              lastError = error;
              await new Promise((r) => setTimeout(r, delay * Math.pow(2, i)));
            }
          }

          throw lastError;
        },

        // Connection pooling hint
        preconnect: (origins) => {
          origins.forEach((origin) => {
            const link = document.createElement("link");
            link.rel = "preconnect";
            link.href = origin;
            document.head.appendChild(link);
          });
        },
      };
    }

    /**
     * Storage Exploitation - Maximize storage efficiency
     */
    async setupStorageExploitation() {
      this.storageExploit = {
        // Compressed storage
        setCompressed: (key, value) => {
          const json = JSON.stringify(value);
          // Simple LZ compression simulation
          const compressed = btoa(json);
          localStorage.setItem(key, compressed);
          return { original: json.length, compressed: compressed.length };
        },

        getCompressed: (key) => {
          const compressed = localStorage.getItem(key);
          if (!compressed) return null;
          try {
            return JSON.parse(atob(compressed));
          } catch {
            return null;
          }
        },

        // Tiered storage
        tieredSet: async (key, value, options = {}) => {
          const size = JSON.stringify(value).length;

          if (size < 1000) {
            // Small: memory
            this.cacheExploit.set(key, value);
          } else if (size < 100000) {
            // Medium: localStorage
            this.storageExploit.setCompressed(key, value);
          } else {
            // Large: IndexedDB
            await this.storageExploit.indexedDBSet(key, value);
          }
        },

        indexedDBSet: async (key, value) => {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open("BaelExploit", 1);

            request.onupgradeneeded = (e) => {
              e.target.result.createObjectStore("data");
            };

            request.onsuccess = (e) => {
              const db = e.target.result;
              const tx = db.transaction("data", "readwrite");
              tx.objectStore("data").put(value, key);
              tx.oncomplete = () => resolve(true);
              tx.onerror = () => reject(tx.error);
            };

            request.onerror = () => reject(request.error);
          });
        },

        // Storage analysis
        analyze: () => {
          const localStorageUsed = Object.keys(localStorage).reduce(
            (acc, key) => acc + key.length + localStorage[key].length,
            0,
          );

          const sessionStorageUsed = Object.keys(sessionStorage).reduce(
            (acc, key) => acc + key.length + sessionStorage[key].length,
            0,
          );

          return {
            localStorage: {
              used: localStorageUsed,
              max: 5 * 1024 * 1024,
              percentage: (localStorageUsed / (5 * 1024 * 1024)) * 100,
            },
            sessionStorage: {
              used: sessionStorageUsed,
              max: 5 * 1024 * 1024,
              percentage: (sessionStorageUsed / (5 * 1024 * 1024)) * 100,
            },
          };
        },
      };
    }

    /**
     * Opportunity scanning
     */
    startOpportunityScanning() {
      setInterval(() => {
        this.scanForOpportunities();
      }, 10000);
    }

    scanForOpportunities() {
      const opportunities = [];

      // Check cache efficiency
      const cacheEfficiency = this.cacheExploit.getEfficiency();
      if (cacheEfficiency < 50) {
        opportunities.push({
          type: "cache",
          message: "Low cache efficiency detected",
          action: "Increase caching aggressiveness",
          potential: "high",
        });
      }

      // Check storage utilization
      const storage = this.storageExploit.analyze();
      if (storage.localStorage.percentage > 80) {
        opportunities.push({
          type: "storage",
          message: "High localStorage usage",
          action: "Migrate to IndexedDB",
          potential: "medium",
        });
      }

      // Check for parallelization opportunities
      opportunities.push({
        type: "parallel",
        message: `${navigator.hardwareConcurrency} cores available`,
        action: "Parallelize more operations",
        potential: "high",
      });

      this.opportunities = opportunities;
      this.emit("opportunities:found", opportunities);
    }

    /**
     * Helper methods
     */
    scoreImportance(sentence) {
      let score = 0;

      // Length factor
      score += Math.min(sentence.length / 100, 1);

      // Keyword factor
      const keywords = [
        "important",
        "critical",
        "must",
        "should",
        "key",
        "main",
        "primary",
      ];
      keywords.forEach((kw) => {
        if (sentence.toLowerCase().includes(kw)) score += 0.2;
      });

      // First sentence bonus
      if (sentence === sentence) score += 0.1;

      return score;
    }

    calculateCacheScore(entry) {
      const age = Date.now() - entry.created;
      const recency = Date.now() - entry.lastAccess;
      const frequency = entry.accessCount;

      // Higher is better
      return frequency * 10 - recency / 1000 - age / 10000;
    }

    scoreContextItem(item) {
      let score = 0;

      if (typeof item === "string") {
        score = item.length / 100;
      } else if (typeof item === "object") {
        score = Object.keys(item).length * 0.5;
        if (item.priority) score += item.priority === "high" ? 2 : 1;
        if (item.recent) score += 1;
      }

      return score;
    }

    generateFingerprint(item) {
      const str = JSON.stringify(item);
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0;
      }
      return hash.toString(36);
    }

    getSystemLoad() {
      // Estimate based on available info
      const mem =
        performance.memory?.usedJSHeapSize /
          performance.memory?.jsHeapSizeLimit || 0.5;
      return mem;
    }

    emit(event, data) {
      window.dispatchEvent(new CustomEvent(event, { detail: data }));
    }

    /**
     * Quick exploit methods
     */
    async autoOptimize(data) {
      // Compress tokens
      if (typeof data === "string") {
        data = this.tokenExploit.compressPrompt(data);
      }

      // Cache result
      const key = this.generateFingerprint(data);
      const cached = this.cacheExploit.get(key);
      if (cached) return cached;

      // Return optimized
      return data;
    }

    getExploitStatus() {
      return {
        cache: {
          size: this.cacheExploit.cache.size,
          efficiency: this.cacheExploit.getEfficiency(),
          stats: this.cacheExploit.stats,
        },
        storage: this.storageExploit.analyze(),
        opportunities: this.opportunities.length,
      };
    }
  }

  // Initialize and export
  window.BaelExploit = new BaelExploit();

  // Auto-initialize
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      window.BaelExploit.initialize();
    });
  } else {
    window.BaelExploit.initialize();
  }
})();
